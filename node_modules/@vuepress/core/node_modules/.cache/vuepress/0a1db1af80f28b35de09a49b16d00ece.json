{"remainingRequest":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\babel-loader\\lib\\index.js??ref--3-1!E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\@vuepress\\markdown-loader\\index.js??ref--1-2!E:\\Itway\\itway_home\\itway_blog_vue\\docs\\article\\web\\JS\\DOM\\节点方法.md?vue&type=script&lang=js&","dependencies":[{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\docs\\article\\web\\JS\\DOM\\节点方法.md","mtime":1661693194418},{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1615820727224},{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\babel-loader\\lib\\index.js","mtime":1650788052886},{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1615820727224},{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\vue-loader\\lib\\index.js","mtime":1661438026591},{"path":"E:\\Itway\\itway_home\\itway_blog_vue\\node_modules\\@vuepress\\markdown-loader\\index.js","mtime":1661438025926}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Y29uc3QgZm9vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpOwpjb25zdCBiYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFyJyk7CmNvbnNvbGUubG9nKGZvby5oYXNDaGlsZE5vZGVzKTsgLy8gdHJ1ZQoKY29uc29sZS5sb2coYmFyLmhhc0NoaWxkTm9kZXMpOyAvLyBmYWxzZQ=="},{"version":3,"mappings":"AAiNA;AACA;AAEAA,+B,CACA;;AACAA,+B,CACA","names":["console"],"sourceRoot":"docs/article/web/JS/Dom","sources":["节点方法.md"],"sourcesContent":["<template>\n<ContentSlotsDistributor :slot-key=\"$parent.slotKey\"><p>Node 方法\n由于关系指针都是只读的，因此 DOM 提供了一些操作节点的方法。</p>\n<p>增删改型方法\ninsertBefore\n在当前节点下增加一个子节点 Node，并使该子节点位于参考节点的前面。</p>\n<p>📖 语法：</p>\n<p>Node.insertBefore(node);\n🌰 示例：</p>\n<p>const foo = document.getElementById('foo');\nconst bar = document.getElementId('bar');</p>\n<p>foo.insertBefore(bar);\nappendChild\n将指定的 childNode 参数作为最后一个子节点添加到当前节点。 如果参数引用了 DOM 树上的现有节点，则节点将从当前位置分离，并附加到新位置。</p>\n<p>📖 语法：</p>\n<p>Node.appendChild(node);\n参数 node 为被插入的 DOM 节点引用。</p>\n<p>🌰 示例：</p>\n<p>const foo = document.getElementById('foo');\nconst bar = document.getElementId('bar');</p>\n<p>foo.appendChild(bar);\n如果被插入的节点已经存在于当前文档的文档树中，则那个节点会首先从原先的位置移除，然后再插入到新的位置\n如果你需要保留这个子节点在原先位置的显示，则你需要先用 Node.cloneNode 方法复制出一个节点的副本，然后在插入到新位置\n这个方法只能将某个子节点插入到同一个文档的其他位置,如果你想跨文档插入，你需要先调用 document.importNode 方法\nreplaceChild\n替换当前节点的某个指定子节点为指定的节点。</p>\n<p>📖 语法：</p>\n<p>Node.replaceChild(newChild, oldChild);\n🌰 示例：</p>\n<div id=\"foo\">\n  <div class=\"bar\"></div>\n</div>\n创建一个 span 元素并将其替代 foo 的第一个元素节点。\n<p>const span = document.createElement('span');\nconst foo = document.getElementById('foo');\nconst bar = foo.firstElementChild;</p>\n<p>foo.replace(bar, span);\n运行后：</p>\n<div id=\"foo\">\n  <span></span>\n</div>\nremoveChild\n从 DOM 中删除一个子节点，返回删除的节点。\n<p>📖 语法：</p>\n<p>Node.removeChild(node);\n🌰 示例：</p>\n<div id=\"foo\">\n  <div id=\"bar\"></div>\n</div>\nconst foo = document.getElementById('foo');\nconst bar = document.getElementById('bar');\n<p>foo.removeChild(bar);\n运行后：</p>\n<div id=\"foo\"></div>\ncloneNode()\n克隆节点到当前节点的子节点列表（及其属性和后代节点）。\n<p>📖 语法：</p>\n<p>Node.cloneNode(deep);\n参数 deep 为 Boolean 类型，表示是否采用深度克隆，如果是 true，则该节点的所有后代节点也会被克隆，如果为 false，则只克隆该节点本身。</p>\n<p>🌰 示例：</p>\n<div id=\"foo\">\n  <div></div>\n  <div></div>\n</div>\nconst foo = document.getElementById('foo');\n<p>const backup = foo.cloneNode();</p>\n<p>foo.appendChild(backup);\n运行后：</p>\n<div id=\"foo\">\n  <div></div>\n  <div></div>\n  <!-- 克隆后插入到子节点列表最后 -->\n  <div id=\"foo\"></div>\n</div>\n克隆一个元素节点会拷贝它所有属性及属性值，当然也就包括了属性上绑定的事件，但不会绑定那些使用 addEventListener() 方法或者 node.onClick = fn 这种 JavaScrept 动态绑定的事件。\n在使用 Node.appendChild() 或类似的方法将拷贝的节点添加到文档中之前，那个拷贝节点并不属于当前文档树的一部分，也就是说，它没有父节点。\n如果 deep 参数设为 false，则不克隆它的任何子节点，该节点所包含的所有文本也不会被克隆，因为文本本身也是一个或多个 Text 节点。\n如果 deep 参数设为 true，则会拷贝整棵 DOM 子树（包括那些可能存在的 Text 子节点）。对于空节点（例如 <img> 或 <input> 元素），则 deep 参数无论是 true 还是 false ，都没有关系，但是仍然需要为它指定一个值。\n为了防止一个文档中出现两个 ID 重复的元素，使用 cloneNode() 方法克隆的节点在需要时应该指定另一个与原 ID 值不同的 ID。\n如果原始节点设置了 ID，并且克隆节点会被插入到相同的文档中，那么应该更新克隆节点的 ID 以保证唯一性。name 属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。\n判定型方法\nhasChildNodes\n判断当前节点是否含有子节点\n<p>📖 语法：</p>\n<p>Node.hasChildNodes();\n🌰 示例：</p>\n<div id=\"foo\">\n  <div id=\"bar\"></div>\n</div>\n<p>isEqualNode\n判断两个节点是否相等。</p>\n<p>当两个节点的类型相同，定义特征（defining characteristics）相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。一些具体的数据指出：多数时候的比较是根据节点的类型来的。</p>\n<p>📖 语法：</p>\n<p>Node.isEqualNode(node);\n🌰 示例：</p>\n<ul class=\"list\">\n  <li>Hello world!</li>\n  <li>I am the champion!</li>\n  <li>Hello world!</li>\n</ul>\nconst items = document.getElementsByClassName('list')[0].children;\n<p>consolg.log(items[0].isEqualNode(items[1]));\n// false\nconsolg.log(items[0].isEqualNode(items[2]));\n// true\ncompareDocumentPosition\n比较当前节点与任意文档中的另一节点的位置关系</p>\n<p>📖 语法：</p>\n<p>Node.compareDocumentPosition(node);\n🌰 示例：</p>\n<p>var head = document.getElementsByTagName('head').item(0);\nif (head.compareDocumentPosition(document.body) &amp; Node.DOCUMENT_POSITION_FOLLOWING) {\nconsole.log('well-formed document');\n} else {\nconsole.log('<head> is not before <body>');\n}\nnormalize\n规范化当前节点及其后代节点</p>\n<p>在一个规范化后的 DOM 树中，不存在一个空的文本节点，或者两个相邻的文本节点。</p>\n<p>📖 语法：</p>\n<p>Node.normalize();\n🌰 示例：</p>\n<p>const wrapper = document.createElement('div');</p>\n<p>wrapper.appendChild(document.createTextNode('Part 1'));\nwrapper.appendChild(document.createTextNode('Part 2'));</p>\n<p>// 规范花前：wrapper.childNodes.length === 2\n// wrapper.childNodes[0].textContent === 'Part 1'\n// wrapper.childNodes[0].textContent === 'Part 2'</p>\n<p>wrapper.normalize();\n// 规范化后：wrapper.childNodes.length === 1\n// wrapper.childNodes[0].textContent === 'Part 1 Part 2'\nChildNode 方法\nChildNode 继承于 Node，但是有其自身的一些方法。</p>\n<p>ChildNode.remove\n从文档中移除当前节点</p>\n<p>📖 语法：</p>\n<p>ChildNode.remove();\n🌰 示例：</p>\n<ul class=\"list\">\n  <li class=\"item1\"></li>\n  <li class=\"item2\"></li>\n  <li class=\"item3\"></li>\n</ul>\nconst item1 = document.querySelector('.item1');\nconst item2 = document.querySelector('.item2');\n<p>item1.remove();\nitem2.remove();\n运行后：</p>\n<ul class=\"list\">\n  <li class=\"item3\"></li>\n</ul>\nChildNode.before\n在其父节点的子节点列表中插入一些 Node 或 DOMString 对象。插入位置为 ChildNode 之前。DOMString 对象会被以 Text 的形式插入。\n<p>📖 语法：</p>\n<p>ChildNode.before();\n🌰 示例：</p>\n<ul class=\"list\">\n  <li class=\"item1\"></li>\n  <li class=\"item2\"></li>\n  <li class=\"item3\"></li>\n</ul>\nconst item1 = document.querySelector('.item1');\nconst li = document.createElement('li');\nli.innerHTML = 'Hello world!';\n<p>item1.before(li);\n运行后：</p>\n<ul class=\"list\">\n  <li>Hello world!</li>\n  <li class=\"item1\"></li>\n  <li class=\"item2\"></li>\n  <li class=\"item3\"></li>\n</ul>\nChildNode.after\n插入节点到当前节点后面。\n<p>在其父节点的子节点列表中插入一些 Node 或 DOMString 对象。插入位置为 ChildNode 之后。DOMString 对象会被以 Text 的形式插入。</p>\n<p>📖 语法：</p>\n<p>ChildNode.after();\n🌰 示例：</p>\n<ul class=\"list\">\n  <li class=\"item1\"></li>\n  <li class=\"item2\"></li>\n  <li class=\"item3\"></li>\n</ul>\nconst item1 = document.querySelector('.item1');\nconst li = document.createElement('li');\nli.innerHTML = 'Hello world!';\n<p>item1.after(li);\n运行后：</p>\n<ul class=\"list\">\n  <li class=\"item1\"></li>\n  <li class=\"item2\"></li>\n  <li class=\"item3\"></li>\n  <li>Hello world!</li>\n</ul>\nChildNode.replaceWith\n替换当前节点为另一节点。\n<p>📖 语法：</p>\n<p>ChildNode.replaceWith(node);\n🌰 示例：</p>\n<p>const parent = document.createElement('div');\nconst child = document.createElment('p');</p>\n<p>parent.appendChild(child);\nconst span = document.createElement('span');</p>\n<p>child.replaceWith(span);</p>\n<p>console.log(parent.outerHTML);\n// '<div><span></span></div>'</p>\n</ContentSlotsDistributor>\n</template>\n<script type=\"text/javascript\">\n  const foo = document.getElementById('foo');\n  const bar = document.getElementById('bar');\n\n  console.log(foo.hasChildNodes);\n  // true\n  console.log(bar.hasChildNodes);\n  // false\n</script>\n\n\n"]}]}