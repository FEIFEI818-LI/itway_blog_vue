{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{235:function(e,t,n){\"use strict\";n.r(t);var o=n(236),i=n.n(o);for(var l in o)[\"default\"].indexOf(l)<0&&function(e){n.d(t,e,(function(){return o[e]}))}(l);t.default=i.a},236:function(e,t){const n=document.getElementById(\"foo\"),o=document.getElementById(\"bar\");console.log(n.hasChildNodes),console.log(o.hasChildNodes)},273:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return o})),n.d(t,\"b\",(function(){return i}));var o=function(){var e=this,t=e._self._c;e._self._setupProxy;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"p\",[e._v(\"Node 方法\\n由于关系指针都是只读的，因此 DOM 提供了一些操作节点的方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"增删改型方法\\ninsertBefore\\n在当前节点下增加一个子节点 Node，并使该子节点位于参考节点的前面。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.insertBefore(node);\\n🌰 示例：\")]),e._v(\" \"),t(\"p\",[e._v(\"const foo = document.getElementById('foo');\\nconst bar = document.getElementId('bar');\")]),e._v(\" \"),t(\"p\",[e._v(\"foo.insertBefore(bar);\\nappendChild\\n将指定的 childNode 参数作为最后一个子节点添加到当前节点。 如果参数引用了 DOM 树上的现有节点，则节点将从当前位置分离，并附加到新位置。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.appendChild(node);\\n参数 node 为被插入的 DOM 节点引用。\")]),e._v(\" \"),t(\"p\",[e._v(\"🌰 示例：\")]),e._v(\" \"),t(\"p\",[e._v(\"const foo = document.getElementById('foo');\\nconst bar = document.getElementId('bar');\")]),e._v(\" \"),t(\"p\",[e._v(\"foo.appendChild(bar);\\n如果被插入的节点已经存在于当前文档的文档树中，则那个节点会首先从原先的位置移除，然后再插入到新的位置\\n如果你需要保留这个子节点在原先位置的显示，则你需要先用 Node.cloneNode 方法复制出一个节点的副本，然后在插入到新位置\\n这个方法只能将某个子节点插入到同一个文档的其他位置,如果你想跨文档插入，你需要先调用 document.importNode 方法\\nreplaceChild\\n替换当前节点的某个指定子节点为指定的节点。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.replaceChild(newChild, oldChild);\\n🌰 示例：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"div\",{staticClass:\"bar\"})]),e._v(\"\\n创建一个 span 元素并将其替代 foo 的第一个元素节点。\\n\"),t(\"p\",[e._v(\"const span = document.createElement('span');\\nconst foo = document.getElementById('foo');\\nconst bar = foo.firstElementChild;\")]),e._v(\" \"),t(\"p\",[e._v(\"foo.replace(bar, span);\\n运行后：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"span\")]),e._v(\"\\nremoveChild\\n从 DOM 中删除一个子节点，返回删除的节点。\\n\"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.removeChild(node);\\n🌰 示例：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"div\",{attrs:{id:\"bar\"}})]),e._v(\"\\nconst foo = document.getElementById('foo');\\nconst bar = document.getElementById('bar');\\n\"),t(\"p\",[e._v(\"foo.removeChild(bar);\\n运行后：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}}),e._v(\"\\ncloneNode()\\n克隆节点到当前节点的子节点列表（及其属性和后代节点）。\\n\"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.cloneNode(deep);\\n参数 deep 为 Boolean 类型，表示是否采用深度克隆，如果是 true，则该节点的所有后代节点也会被克隆，如果为 false，则只克隆该节点本身。\")]),e._v(\" \"),t(\"p\",[e._v(\"🌰 示例：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"div\"),e._v(\" \"),t(\"div\")]),e._v(\"\\nconst foo = document.getElementById('foo');\\n\"),t(\"p\",[e._v(\"const backup = foo.cloneNode();\")]),e._v(\" \"),t(\"p\",[e._v(\"foo.appendChild(backup);\\n运行后：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"div\"),e._v(\" \"),t(\"div\"),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}})]),e._v(\"\\n克隆一个元素节点会拷贝它所有属性及属性值，当然也就包括了属性上绑定的事件，但不会绑定那些使用 addEventListener() 方法或者 node.onClick = fn 这种 JavaScrept 动态绑定的事件。\\n在使用 Node.appendChild() 或类似的方法将拷贝的节点添加到文档中之前，那个拷贝节点并不属于当前文档树的一部分，也就是说，它没有父节点。\\n如果 deep 参数设为 false，则不克隆它的任何子节点，该节点所包含的所有文本也不会被克隆，因为文本本身也是一个或多个 Text 节点。\\n如果 deep 参数设为 true，则会拷贝整棵 DOM 子树（包括那些可能存在的 Text 子节点）。对于空节点（例如 \"),t(\"img\"),e._v(\" 或 \"),t(\"input\"),e._v(\" 元素），则 deep 参数无论是 true 还是 false ，都没有关系，但是仍然需要为它指定一个值。\\n为了防止一个文档中出现两个 ID 重复的元素，使用 cloneNode() 方法克隆的节点在需要时应该指定另一个与原 ID 值不同的 ID。\\n如果原始节点设置了 ID，并且克隆节点会被插入到相同的文档中，那么应该更新克隆节点的 ID 以保证唯一性。name 属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。\\n判定型方法\\nhasChildNodes\\n判断当前节点是否含有子节点\\n\"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.hasChildNodes();\\n🌰 示例：\")]),e._v(\" \"),t(\"div\",{attrs:{id:\"foo\"}},[t(\"div\",{attrs:{id:\"bar\"}})]),e._v(\" \"),t(\"p\",[e._v(\"isEqualNode\\n判断两个节点是否相等。\")]),e._v(\" \"),t(\"p\",[e._v(\"当两个节点的类型相同，定义特征（defining characteristics）相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。一些具体的数据指出：多数时候的比较是根据节点的类型来的。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.isEqualNode(node);\\n🌰 示例：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",[e._v(\"Hello world!\")]),e._v(\" \"),t(\"li\",[e._v(\"I am the champion!\")]),e._v(\" \"),t(\"li\",[e._v(\"Hello world!\")])]),e._v(\"\\nconst items = document.getElementsByClassName('list')[0].children;\\n\"),t(\"p\",[e._v(\"consolg.log(items[0].isEqualNode(items[1]));\\n// false\\nconsolg.log(items[0].isEqualNode(items[2]));\\n// true\\ncompareDocumentPosition\\n比较当前节点与任意文档中的另一节点的位置关系\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.compareDocumentPosition(node);\\n🌰 示例：\")]),e._v(\" \"),t(\"p\",[e._v(\"var head = document.getElementsByTagName('head').item(0);\\nif (head.compareDocumentPosition(document.body) & Node.DOCUMENT_POSITION_FOLLOWING) {\\nconsole.log('well-formed document');\\n} else {\\nconsole.log('\")]),t(\"head\",[e._v(\" is not before \"),t(\"body\",[e._v(\"');\\n}\\nnormalize\\n规范化当前节点及其后代节点\"),t(\"p\"),e._v(\" \"),t(\"p\",[e._v(\"在一个规范化后的 DOM 树中，不存在一个空的文本节点，或者两个相邻的文本节点。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"Node.normalize();\\n🌰 示例：\")]),e._v(\" \"),t(\"p\",[e._v(\"const wrapper = document.createElement('div');\")]),e._v(\" \"),t(\"p\",[e._v(\"wrapper.appendChild(document.createTextNode('Part 1'));\\nwrapper.appendChild(document.createTextNode('Part 2'));\")]),e._v(\" \"),t(\"p\",[e._v(\"// 规范花前：wrapper.childNodes.length === 2\\n// wrapper.childNodes[0].textContent === 'Part 1'\\n// wrapper.childNodes[0].textContent === 'Part 2'\")]),e._v(\" \"),t(\"p\",[e._v(\"wrapper.normalize();\\n// 规范化后：wrapper.childNodes.length === 1\\n// wrapper.childNodes[0].textContent === 'Part 1 Part 2'\\nChildNode 方法\\nChildNode 继承于 Node，但是有其自身的一些方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"ChildNode.remove\\n从文档中移除当前节点\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"ChildNode.remove();\\n🌰 示例：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",{staticClass:\"item1\"}),e._v(\" \"),t(\"li\",{staticClass:\"item2\"}),e._v(\" \"),t(\"li\",{staticClass:\"item3\"})]),e._v(\"\\nconst item1 = document.querySelector('.item1');\\nconst item2 = document.querySelector('.item2');\\n\"),t(\"p\",[e._v(\"item1.remove();\\nitem2.remove();\\n运行后：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",{staticClass:\"item3\"})]),e._v(\"\\nChildNode.before\\n在其父节点的子节点列表中插入一些 Node 或 DOMString 对象。插入位置为 ChildNode 之前。DOMString 对象会被以 Text 的形式插入。\\n\"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"ChildNode.before();\\n🌰 示例：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",{staticClass:\"item1\"}),e._v(\" \"),t(\"li\",{staticClass:\"item2\"}),e._v(\" \"),t(\"li\",{staticClass:\"item3\"})]),e._v(\"\\nconst item1 = document.querySelector('.item1');\\nconst li = document.createElement('li');\\nli.innerHTML = 'Hello world!';\\n\"),t(\"p\",[e._v(\"item1.before(li);\\n运行后：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",[e._v(\"Hello world!\")]),e._v(\" \"),t(\"li\",{staticClass:\"item1\"}),e._v(\" \"),t(\"li\",{staticClass:\"item2\"}),e._v(\" \"),t(\"li\",{staticClass:\"item3\"})]),e._v(\"\\nChildNode.after\\n插入节点到当前节点后面。\\n\"),t(\"p\",[e._v(\"在其父节点的子节点列表中插入一些 Node 或 DOMString 对象。插入位置为 ChildNode 之后。DOMString 对象会被以 Text 的形式插入。\")]),e._v(\" \"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"ChildNode.after();\\n🌰 示例：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",{staticClass:\"item1\"}),e._v(\" \"),t(\"li\",{staticClass:\"item2\"}),e._v(\" \"),t(\"li\",{staticClass:\"item3\"})]),e._v(\"\\nconst item1 = document.querySelector('.item1');\\nconst li = document.createElement('li');\\nli.innerHTML = 'Hello world!';\\n\"),t(\"p\",[e._v(\"item1.after(li);\\n运行后：\")]),e._v(\" \"),t(\"ul\",{staticClass:\"list\"},[t(\"li\",{staticClass:\"item1\"}),e._v(\" \"),t(\"li\",{staticClass:\"item2\"}),e._v(\" \"),t(\"li\",{staticClass:\"item3\"}),e._v(\" \"),t(\"li\",[e._v(\"Hello world!\")])]),e._v(\"\\nChildNode.replaceWith\\n替换当前节点为另一节点。\\n\"),t(\"p\",[e._v(\"📖 语法：\")]),e._v(\" \"),t(\"p\",[e._v(\"ChildNode.replaceWith(node);\\n🌰 示例：\")]),e._v(\" \"),t(\"p\",[e._v(\"const parent = document.createElement('div');\\nconst child = document.createElment('p');\")]),e._v(\" \"),t(\"p\",[e._v(\"parent.appendChild(child);\\nconst span = document.createElement('span');\")]),e._v(\" \"),t(\"p\",[e._v(\"child.replaceWith(span);\")]),e._v(\" \"),t(\"p\",[e._v(\"console.log(parent.outerHTML);\\n// '\")]),t(\"div\",[t(\"span\")]),e._v(\"'\"),t(\"p\")])])])},i=[]},274:function(e,t,n){\"use strict\";n.r(t);var o=n(273),i=n(235);for(var l in i)[\"default\"].indexOf(l)<0&&function(e){n.d(t,e,(function(){return i[e]}))}(l);var d=n(10),s=Object(d.a)(i.default,o.a,o.b,!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}